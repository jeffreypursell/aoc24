Register A: 50230824
Register B: 0
Register C: 0

Program: 2,4,1,3,7,5,0,3,1,4,4,7,5,5,3,0

2,4: bst(4)
  reg[1] = reg[0] % 8
1,3: bxl(3)
  reg[1] ^= 3
7,5: cdv(5)
  reg[2] = reg[0] / 2.pow(reg[1])
0,3: adv(3)
  reg[0] /= 8
1,4: bxl(4)
  reg[1] ^= 4
4,7: bxc(7)
  reg[1] ^= reg[2]
5,5: out(5)
  yield reg[1] % 8
3,0: jnz(0)
  if reg[0] != 0 {
    goto 0
  }

while reg[0] != 0 {
  reg[1] = reg[0] % 8;
  reg[1] ^= 3;
  reg[2] = reg[0] / 2.pow(reg[1])
  reg[0] /= 8
  reg[1] ^= 4
  reg[1] ^= reg[2]
  yield reg[1] % 8
}

what if we ran it backwards? the output comes from register[1] and we know what
that should be modulo 8, so we could just set that maybe. Then set the other
registers to 0 I guess and see what you end up with after it eats all the
"output" in reverse.